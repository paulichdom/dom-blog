---
title: 'Exploring Closures in JavaScript: Examples and Use Cases'
date: '10-04-2023'
excerpt: 'A closure forms when a function is defined within another, retaining variable access post-execution. Understanding closures enables effective use of private variables, callbacks, event handlers, and more.'
isFeatured: true
---

In the realm of JavaScript, closures play a pivotal role in enhancing the functionality and flexibility of code.
They are formed when a function is created, allowing it to access variables from its surrounding environment.
This ingenious concept empowers developers to encapsulate specific variables within functions,
without cluttering the broader scope.

<br />
Closures have become a cornerstone of various programming paradigms, such as Functional
Programming (FP) and module-based designs. They even lend a hand in shaping class-oriented
approaches. It's no exaggeration to say that closures are one of the most influential
language features in the history of programming.
<br />
To truly master JavaScript and leverage its full potential, it is crucial to grasp
the intricacies of closures. By harnessing this powerful concept, developers can
unlock the door to efficient coding and effectively employ a range of essential design
patterns throughout their projects.

## What is a Closure?

Closure builds on this approach: for variables we need to use over time, instead of placing them in larger outer scopes,
we can encapsulate (more narrowly scope) them but still preserve access from inside functions, for broader use.
Functions remember these referenced scoped variables via closure
(<cite>Simpson, 2014, "You Don't Know JS: Scope & Closures"</cite>).

<br />
Put simply, a closure grants access to the scope of an outer function from within
an inner function. In the realm of JavaScript, closures are formed each time a function
is created, precisely at the moment of function creation.
<br />
In the realm of programming, closure emerges as a unique behavior inherent to functions
alone. Its essence lies solely within the domain of functions. Consequently, closure
does not extend to objects or classes, although individual functions or methods within
a class may possess closure. Thus, it is imperative to recognize that closure is
a characteristic exclusive to functions.
<br />
Let's look at a simple counter function in our first code example:{' '}

```ts
function createCounter(): () => void {
  let count = 0;

  function increment(): void {
    count++;
    console.log(count);
  }

  return increment;
}

const counter: () => void = createCounter();

counter(); // Output: 1
counter(); // Output: 2
counter(); // Output: 3
```

In this example, the `createCounter` function returns an inner function `increment`.
The `count` variable is enclosed within the scope of the `createCounter` function, forming a closure.
When the `increment` function is invoked through the `counter` variable,
it can access and modify the `count` variable, even though it's no longer within its original lexical scope.

<br />
The closure ensures that the `count` variable is preserved between function calls,
allowing the counter to increment correctly with each invocation. This showcases
the power of closures in encapsulating and persisting data within a function's scope,
even after the outer function has finished executing.
<br />
This example highlights the versatility and practicality of closures, demonstrating
how they can be utilized to create self-contained functions with their own internal
state, providing a reliable and efficient solution to various programming scenarios.
<br />
More on [Lambda Calculus And Closure](https://www.kimsereylam.com/racket/2019/02/06/lambda-calculus-and-closure.html#:~:text=A%20closure%20is%20a%20record,bindings%20for%20all%20its%20variables)

## Examples of Closures in JavaScript

To help understand closures, let's look at a few examples of how they can be used in JavaScript.

![Closure image](/images/posts/exploring-closures-in-javascript/exploring-closures-in-javascript.png)
